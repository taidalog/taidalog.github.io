/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/App.fs.js":
/*!***********************!*\
  !*** ./src/App.fs.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"keyboardshortcut\": () => (/* binding */ keyboardshortcut)\n/* harmony export */ });\n/* harmony import */ var _fable_modules_fable_library_4_5_0_Array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fable_modules/fable-library.4.5.0/Array.js */ \"./src/fable_modules/fable-library.4.5.0/Array.js\");\n/* harmony import */ var _fable_modules_fable_library_4_5_0_Util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fable_modules/fable-library.4.5.0/Util.js */ \"./src/fable_modules/fable-library.4.5.0/Util.js\");\n\r\n\r\n\r\nfunction keyboardshortcut(e) {\r\n    let x;\r\n    const informationPolicyWindow = document.getElementById(\"informationPolicyWindow\");\r\n    const isInformationPolicyWindowActive = (0,_fable_modules_fable_library_4_5_0_Array_js__WEBPACK_IMPORTED_MODULE_0__.contains)(\"active\", (x = informationPolicyWindow.classList, Array.from(x)), {\r\n        Equals: (x_1, y) => (x_1 === y),\r\n        GetHashCode: _fable_modules_fable_library_4_5_0_Util_js__WEBPACK_IMPORTED_MODULE_1__.stringHash,\r\n    });\r\n    if (e.key === \"Escape\") {\r\n        if (isInformationPolicyWindowActive) {\r\n            informationPolicyWindow.classList.remove(\"active\");\r\n        }\r\n    }\r\n}\r\n\r\nwindow.addEventListener(\"DOMContentLoaded\", (_arg) => {\r\n    document.getElementById(\"informationPolicyLink\").onclick = ((event) => {\r\n        event.preventDefault();\r\n        document.getElementById(\"informationPolicyWindow\").classList.add(\"active\");\r\n    });\r\n    document.getElementById(\"informationPolicyClose\").onclick = ((_arg_1) => {\r\n        document.getElementById(\"informationPolicyWindow\").classList.remove(\"active\");\r\n    });\r\n    document.onkeydown = ((e) => {\r\n        keyboardshortcut(e);\r\n    });\r\n});\r\n\r\n\n\n//# sourceURL=webpack:///./src/App.fs.js?");

/***/ }),

/***/ "./src/fable_modules/fable-library.4.5.0/Array.js":
/*!********************************************************!*\
  !*** ./src/fable_modules/fable-library.4.5.0/Array.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"addInPlace\": () => (/* binding */ addInPlace),\n/* harmony export */   \"addRangeInPlace\": () => (/* binding */ addRangeInPlace),\n/* harmony export */   \"allPairs\": () => (/* binding */ allPairs),\n/* harmony export */   \"append\": () => (/* binding */ append),\n/* harmony export */   \"average\": () => (/* binding */ average),\n/* harmony export */   \"averageBy\": () => (/* binding */ averageBy),\n/* harmony export */   \"choose\": () => (/* binding */ choose),\n/* harmony export */   \"chunkBySize\": () => (/* binding */ chunkBySize),\n/* harmony export */   \"collect\": () => (/* binding */ collect),\n/* harmony export */   \"compareTo\": () => (/* binding */ compareTo),\n/* harmony export */   \"compareWith\": () => (/* binding */ compareWith),\n/* harmony export */   \"concat\": () => (/* binding */ concat),\n/* harmony export */   \"contains\": () => (/* binding */ contains),\n/* harmony export */   \"copy\": () => (/* binding */ copy),\n/* harmony export */   \"copyTo\": () => (/* binding */ copyTo),\n/* harmony export */   \"empty\": () => (/* binding */ empty),\n/* harmony export */   \"equalsWith\": () => (/* binding */ equalsWith),\n/* harmony export */   \"exactlyOne\": () => (/* binding */ exactlyOne),\n/* harmony export */   \"exists\": () => (/* binding */ exists),\n/* harmony export */   \"exists2\": () => (/* binding */ exists2),\n/* harmony export */   \"existsOffset\": () => (/* binding */ existsOffset),\n/* harmony export */   \"existsOffset2\": () => (/* binding */ existsOffset2),\n/* harmony export */   \"fill\": () => (/* binding */ fill),\n/* harmony export */   \"filter\": () => (/* binding */ filter),\n/* harmony export */   \"find\": () => (/* binding */ find),\n/* harmony export */   \"findBack\": () => (/* binding */ findBack),\n/* harmony export */   \"findIndex\": () => (/* binding */ findIndex),\n/* harmony export */   \"findIndexBack\": () => (/* binding */ findIndexBack),\n/* harmony export */   \"findLastIndex\": () => (/* binding */ findLastIndex),\n/* harmony export */   \"fold\": () => (/* binding */ fold),\n/* harmony export */   \"fold2\": () => (/* binding */ fold2),\n/* harmony export */   \"foldBack\": () => (/* binding */ foldBack),\n/* harmony export */   \"foldBack2\": () => (/* binding */ foldBack2),\n/* harmony export */   \"foldBackIndexed\": () => (/* binding */ foldBackIndexed),\n/* harmony export */   \"foldBackIndexed2\": () => (/* binding */ foldBackIndexed2),\n/* harmony export */   \"foldIndexed\": () => (/* binding */ foldIndexed),\n/* harmony export */   \"foldIndexed2\": () => (/* binding */ foldIndexed2),\n/* harmony export */   \"forAll\": () => (/* binding */ forAll),\n/* harmony export */   \"forAll2\": () => (/* binding */ forAll2),\n/* harmony export */   \"getSubArray\": () => (/* binding */ getSubArray),\n/* harmony export */   \"head\": () => (/* binding */ head),\n/* harmony export */   \"indexOf\": () => (/* binding */ indexOf),\n/* harmony export */   \"indexed\": () => (/* binding */ indexed),\n/* harmony export */   \"initialize\": () => (/* binding */ initialize),\n/* harmony export */   \"insertAt\": () => (/* binding */ insertAt),\n/* harmony export */   \"insertManyAt\": () => (/* binding */ insertManyAt),\n/* harmony export */   \"insertRangeInPlace\": () => (/* binding */ insertRangeInPlace),\n/* harmony export */   \"isEmpty\": () => (/* binding */ isEmpty),\n/* harmony export */   \"item\": () => (/* binding */ item),\n/* harmony export */   \"iterate\": () => (/* binding */ iterate),\n/* harmony export */   \"iterate2\": () => (/* binding */ iterate2),\n/* harmony export */   \"iterateIndexed\": () => (/* binding */ iterateIndexed),\n/* harmony export */   \"iterateIndexed2\": () => (/* binding */ iterateIndexed2),\n/* harmony export */   \"last\": () => (/* binding */ last),\n/* harmony export */   \"map\": () => (/* binding */ map),\n/* harmony export */   \"map2\": () => (/* binding */ map2),\n/* harmony export */   \"map3\": () => (/* binding */ map3),\n/* harmony export */   \"mapFold\": () => (/* binding */ mapFold),\n/* harmony export */   \"mapFoldBack\": () => (/* binding */ mapFoldBack),\n/* harmony export */   \"mapIndexed\": () => (/* binding */ mapIndexed),\n/* harmony export */   \"mapIndexed2\": () => (/* binding */ mapIndexed2),\n/* harmony export */   \"mapIndexed3\": () => (/* binding */ mapIndexed3),\n/* harmony export */   \"max\": () => (/* binding */ max),\n/* harmony export */   \"maxBy\": () => (/* binding */ maxBy),\n/* harmony export */   \"min\": () => (/* binding */ min),\n/* harmony export */   \"minBy\": () => (/* binding */ minBy),\n/* harmony export */   \"pairwise\": () => (/* binding */ pairwise),\n/* harmony export */   \"partition\": () => (/* binding */ partition),\n/* harmony export */   \"permute\": () => (/* binding */ permute),\n/* harmony export */   \"pick\": () => (/* binding */ pick),\n/* harmony export */   \"reduce\": () => (/* binding */ reduce),\n/* harmony export */   \"reduceBack\": () => (/* binding */ reduceBack),\n/* harmony export */   \"removeAllInPlace\": () => (/* binding */ removeAllInPlace),\n/* harmony export */   \"removeAt\": () => (/* binding */ removeAt),\n/* harmony export */   \"removeInPlace\": () => (/* binding */ removeInPlace),\n/* harmony export */   \"removeManyAt\": () => (/* binding */ removeManyAt),\n/* harmony export */   \"replicate\": () => (/* binding */ replicate),\n/* harmony export */   \"reverse\": () => (/* binding */ reverse),\n/* harmony export */   \"scan\": () => (/* binding */ scan),\n/* harmony export */   \"scanBack\": () => (/* binding */ scanBack),\n/* harmony export */   \"setSlice\": () => (/* binding */ setSlice),\n/* harmony export */   \"singleton\": () => (/* binding */ singleton),\n/* harmony export */   \"skip\": () => (/* binding */ skip),\n/* harmony export */   \"skipWhile\": () => (/* binding */ skipWhile),\n/* harmony export */   \"sort\": () => (/* binding */ sort),\n/* harmony export */   \"sortBy\": () => (/* binding */ sortBy),\n/* harmony export */   \"sortByDescending\": () => (/* binding */ sortByDescending),\n/* harmony export */   \"sortDescending\": () => (/* binding */ sortDescending),\n/* harmony export */   \"sortInPlace\": () => (/* binding */ sortInPlace),\n/* harmony export */   \"sortInPlaceBy\": () => (/* binding */ sortInPlaceBy),\n/* harmony export */   \"sortWith\": () => (/* binding */ sortWith),\n/* harmony export */   \"splitAt\": () => (/* binding */ splitAt),\n/* harmony export */   \"splitInto\": () => (/* binding */ splitInto),\n/* harmony export */   \"sum\": () => (/* binding */ sum),\n/* harmony export */   \"sumBy\": () => (/* binding */ sumBy),\n/* harmony export */   \"tail\": () => (/* binding */ tail),\n/* harmony export */   \"take\": () => (/* binding */ take),\n/* harmony export */   \"takeWhile\": () => (/* binding */ takeWhile),\n/* harmony export */   \"transpose\": () => (/* binding */ transpose),\n/* harmony export */   \"truncate\": () => (/* binding */ truncate),\n/* harmony export */   \"tryExactlyOne\": () => (/* binding */ tryExactlyOne),\n/* harmony export */   \"tryFind\": () => (/* binding */ tryFind),\n/* harmony export */   \"tryFindBack\": () => (/* binding */ tryFindBack),\n/* harmony export */   \"tryFindIndex\": () => (/* binding */ tryFindIndex),\n/* harmony export */   \"tryFindIndexBack\": () => (/* binding */ tryFindIndexBack),\n/* harmony export */   \"tryHead\": () => (/* binding */ tryHead),\n/* harmony export */   \"tryItem\": () => (/* binding */ tryItem),\n/* harmony export */   \"tryLast\": () => (/* binding */ tryLast),\n/* harmony export */   \"tryPick\": () => (/* binding */ tryPick),\n/* harmony export */   \"unfold\": () => (/* binding */ unfold),\n/* harmony export */   \"unzip\": () => (/* binding */ unzip),\n/* harmony export */   \"unzip3\": () => (/* binding */ unzip3),\n/* harmony export */   \"updateAt\": () => (/* binding */ updateAt),\n/* harmony export */   \"where\": () => (/* binding */ where),\n/* harmony export */   \"windowed\": () => (/* binding */ windowed),\n/* harmony export */   \"zip\": () => (/* binding */ zip),\n/* harmony export */   \"zip3\": () => (/* binding */ zip3)\n/* harmony export */ });\n/* harmony import */ var _Native_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Native.js */ \"./src/fable_modules/fable-library.4.5.0/Native.js\");\n/* harmony import */ var _Option_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Option.js */ \"./src/fable_modules/fable-library.4.5.0/Option.js\");\n/* harmony import */ var _Double_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Double.js */ \"./src/fable_modules/fable-library.4.5.0/Double.js\");\n/* harmony import */ var _Util_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Util.js */ \"./src/fable_modules/fable-library.4.5.0/Util.js\");\n/* harmony import */ var _Global_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Global.js */ \"./src/fable_modules/fable-library.4.5.0/Global.js\");\n\n\n\n\n\nfunction indexNotFound() {\n    throw new Error(\"An index satisfying the predicate was not found in the collection.\");\n}\nfunction differentLengths() {\n    throw new Error(\"Arrays had different lengths\");\n}\nfunction append(array1, array2, cons) {\n    const len1 = array1.length | 0;\n    const len2 = array2.length | 0;\n    const newArray = (0,_Native_js__WEBPACK_IMPORTED_MODULE_0__.Helpers_allocateArrayFromCons)(cons, len1 + len2);\n    for (let i = 0; i <= (len1 - 1); i++) {\n        newArray[i] = array1[i];\n    }\n    for (let i_1 = 0; i_1 <= (len2 - 1); i_1++) {\n        newArray[i_1 + len1] = array2[i_1];\n    }\n    return newArray;\n}\nfunction filter(predicate, array) {\n    return array.filter(predicate);\n}\nfunction fill(target, targetIndex, count, value) {\n    const start = targetIndex | 0;\n    return target.fill(value, start, (start + count));\n}\nfunction getSubArray(array, start, count) {\n    const start_1 = start | 0;\n    return array.slice(start_1, (start_1 + count));\n}\nfunction last(array) {\n    if (array.length === 0) {\n        throw new Error(\"The input array was empty\\\\nParameter name: array\");\n    }\n    return array[array.length - 1];\n}\nfunction tryLast(array) {\n    if (array.length === 0) {\n        return void 0;\n    }\n    else {\n        return (0,_Option_js__WEBPACK_IMPORTED_MODULE_1__.some)(array[array.length - 1]);\n    }\n}\nfunction mapIndexed(f, source, cons) {\n    const len = source.length | 0;\n    const target = (0,_Native_js__WEBPACK_IMPORTED_MODULE_0__.Helpers_allocateArrayFromCons)(cons, len);\n    for (let i = 0; i <= (len - 1); i++) {\n        target[i] = f(i, source[i]);\n    }\n    return target;\n}\nfunction map(f, source, cons) {\n    const len = source.length | 0;\n    const target = (0,_Native_js__WEBPACK_IMPORTED_MODULE_0__.Helpers_allocateArrayFromCons)(cons, len);\n    for (let i = 0; i <= (len - 1); i++) {\n        target[i] = f(source[i]);\n    }\n    return target;\n}\nfunction mapIndexed2(f, source1, source2, cons) {\n    if (source1.length !== source2.length) {\n        throw new Error(\"Arrays had different lengths\");\n    }\n    const result = (0,_Native_js__WEBPACK_IMPORTED_MODULE_0__.Helpers_allocateArrayFromCons)(cons, source1.length);\n    for (let i = 0; i <= (source1.length - 1); i++) {\n        result[i] = f(i, source1[i], source2[i]);\n    }\n    return result;\n}\nfunction map2(f, source1, source2, cons) {\n    if (source1.length !== source2.length) {\n        throw new Error(\"Arrays had different lengths\");\n    }\n    const result = (0,_Native_js__WEBPACK_IMPORTED_MODULE_0__.Helpers_allocateArrayFromCons)(cons, source1.length);\n    for (let i = 0; i <= (source1.length - 1); i++) {\n        result[i] = f(source1[i], source2[i]);\n    }\n    return result;\n}\nfunction mapIndexed3(f, source1, source2, source3, cons) {\n    if ((source1.length !== source2.length) ? true : (source2.length !== source3.length)) {\n        throw new Error(\"Arrays had different lengths\");\n    }\n    const result = (0,_Native_js__WEBPACK_IMPORTED_MODULE_0__.Helpers_allocateArrayFromCons)(cons, source1.length);\n    for (let i = 0; i <= (source1.length - 1); i++) {\n        result[i] = f(i, source1[i], source2[i], source3[i]);\n    }\n    return result;\n}\nfunction map3(f, source1, source2, source3, cons) {\n    if ((source1.length !== source2.length) ? true : (source2.length !== source3.length)) {\n        throw new Error(\"Arrays had different lengths\");\n    }\n    const result = (0,_Native_js__WEBPACK_IMPORTED_MODULE_0__.Helpers_allocateArrayFromCons)(cons, source1.length);\n    for (let i = 0; i <= (source1.length - 1); i++) {\n        result[i] = f(source1[i], source2[i], source3[i]);\n    }\n    return result;\n}\nfunction mapFold(mapping, state, array, cons) {\n    const matchValue = array.length | 0;\n    if (matchValue === 0) {\n        return [[], state];\n    }\n    else {\n        let acc = state;\n        const res = (0,_Native_js__WEBPACK_IMPORTED_MODULE_0__.Helpers_allocateArrayFromCons)(cons, matchValue);\n        for (let i = 0; i <= (array.length - 1); i++) {\n            const patternInput = mapping(acc, array[i]);\n            res[i] = patternInput[0];\n            acc = patternInput[1];\n        }\n        return [res, acc];\n    }\n}\nfunction mapFoldBack(mapping, array, state, cons) {\n    const matchValue = array.length | 0;\n    if (matchValue === 0) {\n        return [[], state];\n    }\n    else {\n        let acc = state;\n        const res = (0,_Native_js__WEBPACK_IMPORTED_MODULE_0__.Helpers_allocateArrayFromCons)(cons, matchValue);\n        for (let i = array.length - 1; i >= 0; i--) {\n            const patternInput = mapping(array[i], acc);\n            res[i] = patternInput[0];\n            acc = patternInput[1];\n        }\n        return [res, acc];\n    }\n}\nfunction indexed(source) {\n    const len = source.length | 0;\n    const target = new Array(len);\n    for (let i = 0; i <= (len - 1); i++) {\n        target[i] = [i, source[i]];\n    }\n    return target;\n}\nfunction truncate(count, array) {\n    const count_1 = (0,_Double_js__WEBPACK_IMPORTED_MODULE_2__.max)(0, count) | 0;\n    return array.slice(0, (0 + count_1));\n}\nfunction concat(arrays, cons) {\n    const arrays_1 = Array.isArray(arrays) ? arrays : (Array.from(arrays));\n    const matchValue = arrays_1.length | 0;\n    switch (matchValue) {\n        case 0:\n            return (0,_Native_js__WEBPACK_IMPORTED_MODULE_0__.Helpers_allocateArrayFromCons)(cons, 0);\n        case 1:\n            return arrays_1[0];\n        default: {\n            let totalIdx = 0;\n            let totalLength = 0;\n            for (let idx = 0; idx <= (arrays_1.length - 1); idx++) {\n                const arr_1 = arrays_1[idx];\n                totalLength = ((totalLength + arr_1.length) | 0);\n            }\n            const result = (0,_Native_js__WEBPACK_IMPORTED_MODULE_0__.Helpers_allocateArrayFromCons)(cons, totalLength);\n            for (let idx_1 = 0; idx_1 <= (arrays_1.length - 1); idx_1++) {\n                const arr_2 = arrays_1[idx_1];\n                for (let j = 0; j <= (arr_2.length - 1); j++) {\n                    result[totalIdx] = arr_2[j];\n                    totalIdx = ((totalIdx + 1) | 0);\n                }\n            }\n            return result;\n        }\n    }\n}\nfunction collect(mapping, array, cons) {\n    return concat(map(mapping, array, (0,_Util_js__WEBPACK_IMPORTED_MODULE_3__.defaultOf)()), cons);\n}\nfunction where(predicate, array) {\n    return array.filter(predicate);\n}\nfunction indexOf(array, item_1, start, count, eq) {\n    const start_1 = (0,_Option_js__WEBPACK_IMPORTED_MODULE_1__.defaultArg)(start, 0) | 0;\n    const end$0027 = (0,_Option_js__WEBPACK_IMPORTED_MODULE_1__.defaultArg)((0,_Option_js__WEBPACK_IMPORTED_MODULE_1__.map)((c) => (start_1 + c), count), array.length) | 0;\n    const loop = (i_mut) => {\n        loop: while (true) {\n            const i = i_mut;\n            if (i >= end$0027) {\n                return -1;\n            }\n            else if (eq.Equals(item_1, array[i])) {\n                return i | 0;\n            }\n            else {\n                i_mut = (i + 1);\n                continue loop;\n            }\n            break;\n        }\n    };\n    return loop(start_1) | 0;\n}\nfunction contains(value, array, eq) {\n    return indexOf(array, value, void 0, void 0, eq) >= 0;\n}\nfunction empty(cons) {\n    return (0,_Native_js__WEBPACK_IMPORTED_MODULE_0__.Helpers_allocateArrayFromCons)(cons, 0);\n}\nfunction singleton(value, cons) {\n    const ar = (0,_Native_js__WEBPACK_IMPORTED_MODULE_0__.Helpers_allocateArrayFromCons)(cons, 1);\n    ar[0] = value;\n    return ar;\n}\nfunction initialize(count, initializer, cons) {\n    if (count < 0) {\n        throw new Error(\"The input must be non-negative\\\\nParameter name: count\");\n    }\n    const result = (0,_Native_js__WEBPACK_IMPORTED_MODULE_0__.Helpers_allocateArrayFromCons)(cons, count);\n    for (let i = 0; i <= (count - 1); i++) {\n        result[i] = initializer(i);\n    }\n    return result;\n}\nfunction pairwise(array) {\n    if (array.length < 2) {\n        return [];\n    }\n    else {\n        const count = (array.length - 1) | 0;\n        const result = new Array(count);\n        for (let i = 0; i <= (count - 1); i++) {\n            result[i] = [array[i], array[i + 1]];\n        }\n        return result;\n    }\n}\nfunction replicate(count, initial, cons) {\n    if (count < 0) {\n        throw new Error(\"The input must be non-negative\\\\nParameter name: count\");\n    }\n    const result = (0,_Native_js__WEBPACK_IMPORTED_MODULE_0__.Helpers_allocateArrayFromCons)(cons, count);\n    for (let i = 0; i <= (result.length - 1); i++) {\n        result[i] = initial;\n    }\n    return result;\n}\nfunction copy(array) {\n    return array.slice();\n}\nfunction copyTo(source, sourceIndex, target, targetIndex, count) {\n    (0,_Util_js__WEBPACK_IMPORTED_MODULE_3__.copyToArray)(source, sourceIndex, target, targetIndex, count);\n}\nfunction reverse(array) {\n    const array_2 = array.slice();\n    return array_2.reverse();\n}\nfunction scan(folder, state, array, cons) {\n    const res = (0,_Native_js__WEBPACK_IMPORTED_MODULE_0__.Helpers_allocateArrayFromCons)(cons, array.length + 1);\n    res[0] = state;\n    for (let i = 0; i <= (array.length - 1); i++) {\n        res[i + 1] = folder(res[i], array[i]);\n    }\n    return res;\n}\nfunction scanBack(folder, array, state, cons) {\n    const res = (0,_Native_js__WEBPACK_IMPORTED_MODULE_0__.Helpers_allocateArrayFromCons)(cons, array.length + 1);\n    res[array.length] = state;\n    for (let i = array.length - 1; i >= 0; i--) {\n        res[i] = folder(array[i], res[i + 1]);\n    }\n    return res;\n}\nfunction skip(count, array, cons) {\n    if (count > array.length) {\n        throw new Error(\"count is greater than array length\\\\nParameter name: count\");\n    }\n    if (count === array.length) {\n        return (0,_Native_js__WEBPACK_IMPORTED_MODULE_0__.Helpers_allocateArrayFromCons)(cons, 0);\n    }\n    else {\n        const count_1 = ((count < 0) ? 0 : count) | 0;\n        return array.slice(count_1);\n    }\n}\nfunction skipWhile(predicate, array, cons) {\n    let count = 0;\n    while ((count < array.length) && predicate(array[count])) {\n        count = ((count + 1) | 0);\n    }\n    if (count === array.length) {\n        return (0,_Native_js__WEBPACK_IMPORTED_MODULE_0__.Helpers_allocateArrayFromCons)(cons, 0);\n    }\n    else {\n        const count_1 = count | 0;\n        return array.slice(count_1);\n    }\n}\nfunction take(count, array, cons) {\n    if (count < 0) {\n        throw new Error(\"The input must be non-negative\\\\nParameter name: count\");\n    }\n    if (count > array.length) {\n        throw new Error(\"count is greater than array length\\\\nParameter name: count\");\n    }\n    if (count === 0) {\n        return (0,_Native_js__WEBPACK_IMPORTED_MODULE_0__.Helpers_allocateArrayFromCons)(cons, 0);\n    }\n    else {\n        return array.slice(0, (0 + count));\n    }\n}\nfunction takeWhile(predicate, array, cons) {\n    let count = 0;\n    while ((count < array.length) && predicate(array[count])) {\n        count = ((count + 1) | 0);\n    }\n    if (count === 0) {\n        return (0,_Native_js__WEBPACK_IMPORTED_MODULE_0__.Helpers_allocateArrayFromCons)(cons, 0);\n    }\n    else {\n        const count_1 = count | 0;\n        return array.slice(0, (0 + count_1));\n    }\n}\nfunction addInPlace(x, array) {\n    array.push(x);\n}\nfunction addRangeInPlace(range, array) {\n    const enumerator = (0,_Util_js__WEBPACK_IMPORTED_MODULE_3__.getEnumerator)(range);\n    try {\n        while (enumerator[\"System.Collections.IEnumerator.MoveNext\"]()) {\n            addInPlace(enumerator[\"System.Collections.Generic.IEnumerator`1.get_Current\"](), array);\n        }\n    }\n    finally {\n        (0,_Util_js__WEBPACK_IMPORTED_MODULE_3__.disposeSafe)(enumerator);\n    }\n}\nfunction insertRangeInPlace(index, range, array) {\n    let index_1;\n    let i = index;\n    const enumerator = (0,_Util_js__WEBPACK_IMPORTED_MODULE_3__.getEnumerator)(range);\n    try {\n        while (enumerator[\"System.Collections.IEnumerator.MoveNext\"]()) {\n            const x = enumerator[\"System.Collections.Generic.IEnumerator`1.get_Current\"]();\n            (index_1 = (i | 0), array.splice(index_1, 0, x));\n            i = ((i + 1) | 0);\n        }\n    }\n    finally {\n        (0,_Util_js__WEBPACK_IMPORTED_MODULE_3__.disposeSafe)(enumerator);\n    }\n}\nfunction removeInPlace(item_1, array, eq) {\n    const i = indexOf(array, item_1, void 0, void 0, eq) | 0;\n    if (i > -1) {\n        array.splice(i, 1);\n        return true;\n    }\n    else {\n        return false;\n    }\n}\nfunction removeAllInPlace(predicate, array) {\n    const countRemoveAll = (count) => {\n        const i = (array.findIndex(predicate)) | 0;\n        if (i > -1) {\n            array.splice(i, 1);\n            return (countRemoveAll(count) + 1) | 0;\n        }\n        else {\n            return count | 0;\n        }\n    };\n    return countRemoveAll(0) | 0;\n}\nfunction partition(f, source, cons) {\n    const len = source.length | 0;\n    const res1 = (0,_Native_js__WEBPACK_IMPORTED_MODULE_0__.Helpers_allocateArrayFromCons)(cons, len);\n    const res2 = (0,_Native_js__WEBPACK_IMPORTED_MODULE_0__.Helpers_allocateArrayFromCons)(cons, len);\n    let iTrue = 0;\n    let iFalse = 0;\n    for (let i = 0; i <= (len - 1); i++) {\n        if (f(source[i])) {\n            res1[iTrue] = source[i];\n            iTrue = ((iTrue + 1) | 0);\n        }\n        else {\n            res2[iFalse] = source[i];\n            iFalse = ((iFalse + 1) | 0);\n        }\n    }\n    return [truncate(iTrue, res1), truncate(iFalse, res2)];\n}\nfunction find(predicate, array) {\n    const matchValue = array.find(predicate);\n    if (matchValue == null) {\n        return indexNotFound();\n    }\n    else {\n        return (0,_Option_js__WEBPACK_IMPORTED_MODULE_1__.value)(matchValue);\n    }\n}\nfunction tryFind(predicate, array) {\n    return array.find(predicate);\n}\nfunction findIndex(predicate, array) {\n    const matchValue = (array.findIndex(predicate)) | 0;\n    if (matchValue > -1) {\n        return matchValue | 0;\n    }\n    else {\n        indexNotFound();\n        return -1;\n    }\n}\nfunction tryFindIndex(predicate, array) {\n    const matchValue = (array.findIndex(predicate)) | 0;\n    if (matchValue > -1) {\n        return matchValue;\n    }\n    else {\n        return void 0;\n    }\n}\nfunction pick(chooser, array) {\n    const loop = (i_mut) => {\n        loop: while (true) {\n            const i = i_mut;\n            if (i >= array.length) {\n                return indexNotFound();\n            }\n            else {\n                const matchValue = chooser(array[i]);\n                if (matchValue != null) {\n                    return (0,_Option_js__WEBPACK_IMPORTED_MODULE_1__.value)(matchValue);\n                }\n                else {\n                    i_mut = (i + 1);\n                    continue loop;\n                }\n            }\n            break;\n        }\n    };\n    return loop(0);\n}\nfunction tryPick(chooser, array) {\n    const loop = (i_mut) => {\n        loop: while (true) {\n            const i = i_mut;\n            if (i >= array.length) {\n                return void 0;\n            }\n            else {\n                const matchValue = chooser(array[i]);\n                if (matchValue == null) {\n                    i_mut = (i + 1);\n                    continue loop;\n                }\n                else {\n                    return matchValue;\n                }\n            }\n            break;\n        }\n    };\n    return loop(0);\n}\nfunction findBack(predicate, array) {\n    const loop = (i_mut) => {\n        loop: while (true) {\n            const i = i_mut;\n            if (i < 0) {\n                return indexNotFound();\n            }\n            else if (predicate(array[i])) {\n                return array[i];\n            }\n            else {\n                i_mut = (i - 1);\n                continue loop;\n            }\n            break;\n        }\n    };\n    return loop(array.length - 1);\n}\nfunction tryFindBack(predicate, array) {\n    const loop = (i_mut) => {\n        loop: while (true) {\n            const i = i_mut;\n            if (i < 0) {\n                return void 0;\n            }\n            else if (predicate(array[i])) {\n                return (0,_Option_js__WEBPACK_IMPORTED_MODULE_1__.some)(array[i]);\n            }\n            else {\n                i_mut = (i - 1);\n                continue loop;\n            }\n            break;\n        }\n    };\n    return loop(array.length - 1);\n}\nfunction findLastIndex(predicate, array) {\n    const loop = (i_mut) => {\n        loop: while (true) {\n            const i = i_mut;\n            if (i < 0) {\n                return -1;\n            }\n            else if (predicate(array[i])) {\n                return i | 0;\n            }\n            else {\n                i_mut = (i - 1);\n                continue loop;\n            }\n            break;\n        }\n    };\n    return loop(array.length - 1) | 0;\n}\nfunction findIndexBack(predicate, array) {\n    const loop = (i_mut) => {\n        loop: while (true) {\n            const i = i_mut;\n            if (i < 0) {\n                indexNotFound();\n                return -1;\n            }\n            else if (predicate(array[i])) {\n                return i | 0;\n            }\n            else {\n                i_mut = (i - 1);\n                continue loop;\n            }\n            break;\n        }\n    };\n    return loop(array.length - 1) | 0;\n}\nfunction tryFindIndexBack(predicate, array) {\n    const loop = (i_mut) => {\n        loop: while (true) {\n            const i = i_mut;\n            if (i < 0) {\n                return void 0;\n            }\n            else if (predicate(array[i])) {\n                return i;\n            }\n            else {\n                i_mut = (i - 1);\n                continue loop;\n            }\n            break;\n        }\n    };\n    return loop(array.length - 1);\n}\nfunction choose(chooser, array, cons) {\n    const res = [];\n    for (let i = 0; i <= (array.length - 1); i++) {\n        const matchValue = chooser(array[i]);\n        if (matchValue != null) {\n            const y = (0,_Option_js__WEBPACK_IMPORTED_MODULE_1__.value)(matchValue);\n            res.push(y);\n        }\n    }\n    if ((0,_Util_js__WEBPACK_IMPORTED_MODULE_3__.equals)(cons, (0,_Util_js__WEBPACK_IMPORTED_MODULE_3__.defaultOf)())) {\n        return res;\n    }\n    else {\n        return map((x) => x, res, cons);\n    }\n}\nfunction foldIndexed(folder, state, array) {\n    return array.reduce(((delegateArg, delegateArg_1, delegateArg_2) => folder(delegateArg_2, delegateArg, delegateArg_1)), state);\n}\nfunction fold(folder, state, array) {\n    const folder_1 = folder;\n    return array.reduce((folder_1), state);\n}\nfunction iterate(action, array) {\n    for (let i = 0; i <= (array.length - 1); i++) {\n        action(array[i]);\n    }\n}\nfunction iterateIndexed(action, array) {\n    for (let i = 0; i <= (array.length - 1); i++) {\n        action(i, array[i]);\n    }\n}\nfunction iterate2(action, array1, array2) {\n    if (array1.length !== array2.length) {\n        differentLengths();\n    }\n    for (let i = 0; i <= (array1.length - 1); i++) {\n        action(array1[i], array2[i]);\n    }\n}\nfunction iterateIndexed2(action, array1, array2) {\n    if (array1.length !== array2.length) {\n        differentLengths();\n    }\n    for (let i = 0; i <= (array1.length - 1); i++) {\n        action(i, array1[i], array2[i]);\n    }\n}\nfunction isEmpty(array) {\n    return array.length === 0;\n}\nfunction forAll(predicate, array) {\n    return array.every(predicate);\n}\nfunction permute(f, array) {\n    const size = array.length | 0;\n    const res = array.slice();\n    const checkFlags = new Array(size);\n    iterateIndexed((i, x) => {\n        const j = f(i) | 0;\n        if ((j < 0) ? true : (j >= size)) {\n            throw new Error(\"Not a valid permutation\");\n        }\n        res[j] = x;\n        checkFlags[j] = 1;\n    }, array);\n    if (!(checkFlags.every((y) => (1 === y)))) {\n        throw new Error(\"Not a valid permutation\");\n    }\n    return res;\n}\nfunction setSlice(target, lower, upper, source) {\n    const lower_1 = (0,_Option_js__WEBPACK_IMPORTED_MODULE_1__.defaultArg)(lower, 0) | 0;\n    const upper_1 = (0,_Option_js__WEBPACK_IMPORTED_MODULE_1__.defaultArg)(upper, -1) | 0;\n    const length = (((upper_1 >= 0) ? upper_1 : (target.length - 1)) - lower_1) | 0;\n    for (let i = 0; i <= length; i++) {\n        target[i + lower_1] = source[i];\n    }\n}\nfunction sortInPlaceBy(projection, xs, comparer) {\n    xs.sort((x, y) => comparer.Compare(projection(x), projection(y)));\n}\nfunction sortInPlace(xs, comparer) {\n    xs.sort((x, y) => comparer.Compare(x, y));\n}\nfunction sort(xs, comparer) {\n    const xs_1 = xs.slice();\n    xs_1.sort((x, y) => comparer.Compare(x, y));\n    return xs_1;\n}\nfunction sortBy(projection, xs, comparer) {\n    const xs_1 = xs.slice();\n    xs_1.sort((x, y) => comparer.Compare(projection(x), projection(y)));\n    return xs_1;\n}\nfunction sortDescending(xs, comparer) {\n    const xs_1 = xs.slice();\n    xs_1.sort((x, y) => (comparer.Compare(x, y) * -1));\n    return xs_1;\n}\nfunction sortByDescending(projection, xs, comparer) {\n    const xs_1 = xs.slice();\n    xs_1.sort((x, y) => (comparer.Compare(projection(x), projection(y)) * -1));\n    return xs_1;\n}\nfunction sortWith(comparer, xs) {\n    const comparer_1 = comparer;\n    const xs_1 = xs.slice();\n    xs_1.sort(comparer_1);\n    return xs_1;\n}\nfunction allPairs(xs, ys) {\n    const len1 = xs.length | 0;\n    const len2 = ys.length | 0;\n    const res = new Array(len1 * len2);\n    for (let i = 0; i <= (xs.length - 1); i++) {\n        for (let j = 0; j <= (ys.length - 1); j++) {\n            res[(i * len2) + j] = [xs[i], ys[j]];\n        }\n    }\n    return res;\n}\nfunction unfold(generator, state) {\n    const res = [];\n    const loop = (state_1_mut) => {\n        loop: while (true) {\n            const state_1 = state_1_mut;\n            const matchValue = generator(state_1);\n            if (matchValue != null) {\n                const x = (0,_Option_js__WEBPACK_IMPORTED_MODULE_1__.value)(matchValue)[0];\n                const s = (0,_Option_js__WEBPACK_IMPORTED_MODULE_1__.value)(matchValue)[1];\n                res.push(x);\n                state_1_mut = s;\n                continue loop;\n            }\n            break;\n        }\n    };\n    loop(state);\n    return res;\n}\nfunction unzip(array) {\n    const len = array.length | 0;\n    const res1 = new Array(len);\n    const res2 = new Array(len);\n    iterateIndexed((i, tupledArg) => {\n        res1[i] = tupledArg[0];\n        res2[i] = tupledArg[1];\n    }, array);\n    return [res1, res2];\n}\nfunction unzip3(array) {\n    const len = array.length | 0;\n    const res1 = new Array(len);\n    const res2 = new Array(len);\n    const res3 = new Array(len);\n    iterateIndexed((i, tupledArg) => {\n        res1[i] = tupledArg[0];\n        res2[i] = tupledArg[1];\n        res3[i] = tupledArg[2];\n    }, array);\n    return [res1, res2, res3];\n}\nfunction zip(array1, array2) {\n    if (array1.length !== array2.length) {\n        differentLengths();\n    }\n    const result = new Array(array1.length);\n    for (let i = 0; i <= (array1.length - 1); i++) {\n        result[i] = [array1[i], array2[i]];\n    }\n    return result;\n}\nfunction zip3(array1, array2, array3) {\n    if ((array1.length !== array2.length) ? true : (array2.length !== array3.length)) {\n        differentLengths();\n    }\n    const result = new Array(array1.length);\n    for (let i = 0; i <= (array1.length - 1); i++) {\n        result[i] = [array1[i], array2[i], array3[i]];\n    }\n    return result;\n}\nfunction chunkBySize(chunkSize, array) {\n    if (chunkSize < 1) {\n        throw new Error(\"The input must be positive.\\\\nParameter name: size\");\n    }\n    if (array.length === 0) {\n        return [[]];\n    }\n    else {\n        const result = [];\n        for (let x = 0; x <= (~~Math.ceil(array.length / chunkSize) - 1); x++) {\n            let slice;\n            const start_1 = (x * chunkSize) | 0;\n            slice = (array.slice(start_1, (start_1 + chunkSize)));\n            result.push(slice);\n        }\n        return result;\n    }\n}\nfunction splitAt(index, array) {\n    if ((index < 0) ? true : (index > array.length)) {\n        throw new Error((_Global_js__WEBPACK_IMPORTED_MODULE_4__.SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\");\n    }\n    return [array.slice(0, (0 + index)), array.slice(index)];\n}\nfunction compareWith(comparer, source1, source2) {\n    if (source1 == null) {\n        if (source2 == null) {\n            return 0;\n        }\n        else {\n            return -1;\n        }\n    }\n    else if (source2 == null) {\n        return 1;\n    }\n    else {\n        const len1 = source1.length | 0;\n        const len2 = source2.length | 0;\n        const len = ((len1 < len2) ? len1 : len2) | 0;\n        let i = 0;\n        let res = 0;\n        while ((res === 0) && (i < len)) {\n            res = (comparer(source1[i], source2[i]) | 0);\n            i = ((i + 1) | 0);\n        }\n        if (res !== 0) {\n            return res | 0;\n        }\n        else if (len1 > len2) {\n            return 1;\n        }\n        else if (len1 < len2) {\n            return -1;\n        }\n        else {\n            return 0;\n        }\n    }\n}\nfunction compareTo(comparer, source1, source2) {\n    if (source1 == null) {\n        if (source2 == null) {\n            return 0;\n        }\n        else {\n            return -1;\n        }\n    }\n    else if (source2 == null) {\n        return 1;\n    }\n    else {\n        const len1 = source1.length | 0;\n        const len2 = source2.length | 0;\n        if (len1 > len2) {\n            return 1;\n        }\n        else if (len1 < len2) {\n            return -1;\n        }\n        else {\n            let i = 0;\n            let res = 0;\n            while ((res === 0) && (i < len1)) {\n                res = (comparer(source1[i], source2[i]) | 0);\n                i = ((i + 1) | 0);\n            }\n            return res | 0;\n        }\n    }\n}\nfunction equalsWith(equals, array1, array2) {\n    if (array1 == null) {\n        if (array2 == null) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    else if (array2 == null) {\n        return false;\n    }\n    else {\n        let i = 0;\n        let result = true;\n        const length1 = array1.length | 0;\n        const length2 = array2.length | 0;\n        if (length1 > length2) {\n            return false;\n        }\n        else if (length1 < length2) {\n            return false;\n        }\n        else {\n            while ((i < length1) && result) {\n                result = equals(array1[i], array2[i]);\n                i = ((i + 1) | 0);\n            }\n            return result;\n        }\n    }\n}\nfunction exactlyOne(array) {\n    switch (array.length) {\n        case 1:\n            return array[0];\n        case 0:\n            throw new Error(\"The input sequence was empty\\\\nParameter name: array\");\n        default:\n            throw new Error(\"Input array too long\\\\nParameter name: array\");\n    }\n}\nfunction tryExactlyOne(array) {\n    if (array.length === 1) {\n        return (0,_Option_js__WEBPACK_IMPORTED_MODULE_1__.some)(array[0]);\n    }\n    else {\n        return void 0;\n    }\n}\nfunction head(array) {\n    if (array.length === 0) {\n        throw new Error(\"The input array was empty\\\\nParameter name: array\");\n    }\n    else {\n        return array[0];\n    }\n}\nfunction tryHead(array) {\n    if (array.length === 0) {\n        return void 0;\n    }\n    else {\n        return (0,_Option_js__WEBPACK_IMPORTED_MODULE_1__.some)(array[0]);\n    }\n}\nfunction tail(array) {\n    if (array.length === 0) {\n        throw new Error(\"Not enough elements\\\\nParameter name: array\");\n    }\n    return array.slice(1);\n}\nfunction item(index, array) {\n    return array[index];\n}\nfunction tryItem(index, array) {\n    if ((index < 0) ? true : (index >= array.length)) {\n        return void 0;\n    }\n    else {\n        return (0,_Option_js__WEBPACK_IMPORTED_MODULE_1__.some)(array[index]);\n    }\n}\nfunction foldBackIndexed(folder, array, state) {\n    return array.reduceRight(((delegateArg, delegateArg_1, delegateArg_2) => folder(delegateArg_2, delegateArg_1, delegateArg)), state);\n}\nfunction foldBack(folder, array, state) {\n    return array.reduceRight(((delegateArg, delegateArg_1) => folder(delegateArg_1, delegateArg)), state);\n}\nfunction foldIndexed2(folder, state, array1, array2) {\n    let acc = state;\n    if (array1.length !== array2.length) {\n        throw new Error(\"Arrays have different lengths\");\n    }\n    for (let i = 0; i <= (array1.length - 1); i++) {\n        acc = folder(i, acc, array1[i], array2[i]);\n    }\n    return acc;\n}\nfunction fold2(folder, state, array1, array2) {\n    return foldIndexed2((_arg, acc, x, y) => folder(acc, x, y), state, array1, array2);\n}\nfunction foldBackIndexed2(folder, array1, array2, state) {\n    let acc = state;\n    if (array1.length !== array2.length) {\n        differentLengths();\n    }\n    const size = array1.length | 0;\n    for (let i = 1; i <= size; i++) {\n        acc = folder(i - 1, array1[size - i], array2[size - i], acc);\n    }\n    return acc;\n}\nfunction foldBack2(f, array1, array2, state) {\n    return foldBackIndexed2((_arg, x, y, acc) => f(x, y, acc), array1, array2, state);\n}\nfunction reduce(reduction, array) {\n    if (array.length === 0) {\n        throw new Error(\"The input array was empty\");\n    }\n    const reduction_1 = reduction;\n    return array.reduce(reduction_1);\n}\nfunction reduceBack(reduction, array) {\n    if (array.length === 0) {\n        throw new Error(\"The input array was empty\");\n    }\n    const reduction_1 = reduction;\n    return array.reduceRight(reduction_1);\n}\nfunction forAll2(predicate, array1, array2) {\n    return fold2((acc, x, y) => (acc && predicate(x, y)), true, array1, array2);\n}\nfunction existsOffset(predicate_mut, array_mut, index_mut) {\n    existsOffset: while (true) {\n        const predicate = predicate_mut, array = array_mut, index = index_mut;\n        if (index === array.length) {\n            return false;\n        }\n        else if (predicate(array[index])) {\n            return true;\n        }\n        else {\n            predicate_mut = predicate;\n            array_mut = array;\n            index_mut = (index + 1);\n            continue existsOffset;\n        }\n        break;\n    }\n}\nfunction exists(predicate, array) {\n    return existsOffset(predicate, array, 0);\n}\nfunction existsOffset2(predicate_mut, array1_mut, array2_mut, index_mut) {\n    existsOffset2: while (true) {\n        const predicate = predicate_mut, array1 = array1_mut, array2 = array2_mut, index = index_mut;\n        if (index === array1.length) {\n            return false;\n        }\n        else if (predicate(array1[index], array2[index])) {\n            return true;\n        }\n        else {\n            predicate_mut = predicate;\n            array1_mut = array1;\n            array2_mut = array2;\n            index_mut = (index + 1);\n            continue existsOffset2;\n        }\n        break;\n    }\n}\nfunction exists2(predicate, array1, array2) {\n    if (array1.length !== array2.length) {\n        differentLengths();\n    }\n    return existsOffset2(predicate, array1, array2, 0);\n}\nfunction sum(array, adder) {\n    let acc = adder.GetZero();\n    for (let i = 0; i <= (array.length - 1); i++) {\n        acc = adder.Add(acc, array[i]);\n    }\n    return acc;\n}\nfunction sumBy(projection, array, adder) {\n    let acc = adder.GetZero();\n    for (let i = 0; i <= (array.length - 1); i++) {\n        acc = adder.Add(acc, projection(array[i]));\n    }\n    return acc;\n}\nfunction maxBy(projection, xs, comparer) {\n    return reduce((x, y) => ((comparer.Compare(projection(y), projection(x)) > 0) ? y : x), xs);\n}\nfunction max(xs, comparer) {\n    return reduce((x, y) => ((comparer.Compare(y, x) > 0) ? y : x), xs);\n}\nfunction minBy(projection, xs, comparer) {\n    return reduce((x, y) => ((comparer.Compare(projection(y), projection(x)) > 0) ? x : y), xs);\n}\nfunction min(xs, comparer) {\n    return reduce((x, y) => ((comparer.Compare(y, x) > 0) ? x : y), xs);\n}\nfunction average(array, averager) {\n    if (array.length === 0) {\n        throw new Error(\"The input array was empty\\\\nParameter name: array\");\n    }\n    let total = averager.GetZero();\n    for (let i = 0; i <= (array.length - 1); i++) {\n        total = averager.Add(total, array[i]);\n    }\n    return averager.DivideByInt(total, array.length);\n}\nfunction averageBy(projection, array, averager) {\n    if (array.length === 0) {\n        throw new Error(\"The input array was empty\\\\nParameter name: array\");\n    }\n    let total = averager.GetZero();\n    for (let i = 0; i <= (array.length - 1); i++) {\n        total = averager.Add(total, projection(array[i]));\n    }\n    return averager.DivideByInt(total, array.length);\n}\nfunction windowed(windowSize, source) {\n    if (windowSize <= 0) {\n        throw new Error(\"windowSize must be positive\");\n    }\n    let res;\n    const len = (0,_Double_js__WEBPACK_IMPORTED_MODULE_2__.max)(0, (source.length - windowSize) + 1) | 0;\n    res = (new Array(len));\n    for (let i = windowSize; i <= source.length; i++) {\n        res[i - windowSize] = source.slice(i - windowSize, (i - 1) + 1);\n    }\n    return res;\n}\nfunction splitInto(chunks, array) {\n    if (chunks < 1) {\n        throw new Error(\"The input must be positive.\\\\nParameter name: chunks\");\n    }\n    if (array.length === 0) {\n        return [[]];\n    }\n    else {\n        const result = [];\n        const chunks_1 = (0,_Double_js__WEBPACK_IMPORTED_MODULE_2__.min)(chunks, array.length) | 0;\n        const minChunkSize = ~~(array.length / chunks_1) | 0;\n        const chunksWithExtraItem = (array.length % chunks_1) | 0;\n        for (let i = 0; i <= (chunks_1 - 1); i++) {\n            const chunkSize = ((i < chunksWithExtraItem) ? (minChunkSize + 1) : minChunkSize) | 0;\n            let slice;\n            const start_1 = ((i * minChunkSize) + (0,_Double_js__WEBPACK_IMPORTED_MODULE_2__.min)(chunksWithExtraItem, i)) | 0;\n            slice = (array.slice(start_1, (start_1 + chunkSize)));\n            result.push(slice);\n        }\n        return result;\n    }\n}\nfunction transpose(arrays, cons) {\n    const arrays_1 = Array.isArray(arrays) ? arrays : (Array.from(arrays));\n    const len = arrays_1.length | 0;\n    if (len === 0) {\n        return new Array(0);\n    }\n    else {\n        const firstArray = arrays_1[0];\n        const lenInner = firstArray.length | 0;\n        if (!forAll((a) => (a.length === lenInner), arrays_1)) {\n            differentLengths();\n        }\n        const result = new Array(lenInner);\n        for (let i = 0; i <= (lenInner - 1); i++) {\n            result[i] = (0,_Native_js__WEBPACK_IMPORTED_MODULE_0__.Helpers_allocateArrayFromCons)(cons, len);\n            for (let j = 0; j <= (len - 1); j++) {\n                result[i][j] = arrays_1[j][i];\n            }\n        }\n        return result;\n    }\n}\nfunction insertAt(index, y, xs, cons) {\n    const len = xs.length | 0;\n    if ((index < 0) ? true : (index > len)) {\n        throw new Error((_Global_js__WEBPACK_IMPORTED_MODULE_4__.SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\");\n    }\n    const target = (0,_Native_js__WEBPACK_IMPORTED_MODULE_0__.Helpers_allocateArrayFromCons)(cons, len + 1);\n    for (let i = 0; i <= (index - 1); i++) {\n        target[i] = xs[i];\n    }\n    target[index] = y;\n    for (let i_1 = index; i_1 <= (len - 1); i_1++) {\n        target[i_1 + 1] = xs[i_1];\n    }\n    return target;\n}\nfunction insertManyAt(index, ys, xs, cons) {\n    const len = xs.length | 0;\n    if ((index < 0) ? true : (index > len)) {\n        throw new Error((_Global_js__WEBPACK_IMPORTED_MODULE_4__.SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\");\n    }\n    const ys_1 = Array.from(ys);\n    const len2 = ys_1.length | 0;\n    const target = (0,_Native_js__WEBPACK_IMPORTED_MODULE_0__.Helpers_allocateArrayFromCons)(cons, len + len2);\n    for (let i = 0; i <= (index - 1); i++) {\n        target[i] = xs[i];\n    }\n    for (let i_1 = 0; i_1 <= (len2 - 1); i_1++) {\n        target[index + i_1] = ys_1[i_1];\n    }\n    for (let i_2 = index; i_2 <= (len - 1); i_2++) {\n        target[i_2 + len2] = xs[i_2];\n    }\n    return target;\n}\nfunction removeAt(index, xs) {\n    if ((index < 0) ? true : (index >= xs.length)) {\n        throw new Error((_Global_js__WEBPACK_IMPORTED_MODULE_4__.SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\");\n    }\n    let i = -1;\n    return filter((_arg) => {\n        i = ((i + 1) | 0);\n        return i !== index;\n    }, xs);\n}\nfunction removeManyAt(index, count, xs) {\n    let i = -1;\n    let status = -1;\n    const ys = filter((_arg) => {\n        i = ((i + 1) | 0);\n        if (i === index) {\n            status = 0;\n            return false;\n        }\n        else if (i > index) {\n            if (i < (index + count)) {\n                return false;\n            }\n            else {\n                status = 1;\n                return true;\n            }\n        }\n        else {\n            return true;\n        }\n    }, xs);\n    const status_1 = (((status === 0) && ((i + 1) === (index + count))) ? 1 : status) | 0;\n    if (status_1 < 1) {\n        throw new Error((_Global_js__WEBPACK_IMPORTED_MODULE_4__.SR_indexOutOfBounds + \"\\\\nParameter name: \") + ((status_1 < 0) ? \"index\" : \"count\"));\n    }\n    return ys;\n}\nfunction updateAt(index, y, xs, cons) {\n    const len = xs.length | 0;\n    if ((index < 0) ? true : (index >= len)) {\n        throw new Error((_Global_js__WEBPACK_IMPORTED_MODULE_4__.SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\");\n    }\n    const target = (0,_Native_js__WEBPACK_IMPORTED_MODULE_0__.Helpers_allocateArrayFromCons)(cons, len);\n    for (let i = 0; i <= (len - 1); i++) {\n        target[i] = ((i === index) ? y : xs[i]);\n    }\n    return target;\n}\n\n\n//# sourceURL=webpack:///./src/fable_modules/fable-library.4.5.0/Array.js?");

/***/ }),

/***/ "./src/fable_modules/fable-library.4.5.0/Double.js":
/*!*********************************************************!*\
  !*** ./src/fable_modules/fable-library.4.5.0/Double.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"clamp\": () => (/* binding */ clamp),\n/* harmony export */   \"isInfinity\": () => (/* binding */ isInfinity),\n/* harmony export */   \"isNegativeInfinity\": () => (/* binding */ isNegativeInfinity),\n/* harmony export */   \"isPositiveInfinity\": () => (/* binding */ isPositiveInfinity),\n/* harmony export */   \"max\": () => (/* binding */ max),\n/* harmony export */   \"maxMagnitude\": () => (/* binding */ maxMagnitude),\n/* harmony export */   \"min\": () => (/* binding */ min),\n/* harmony export */   \"minMagnitude\": () => (/* binding */ minMagnitude),\n/* harmony export */   \"parse\": () => (/* binding */ parse),\n/* harmony export */   \"tryParse\": () => (/* binding */ tryParse)\n/* harmony export */ });\n/* harmony import */ var _Types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Types.js */ \"./src/fable_modules/fable-library.4.5.0/Types.js\");\n\nfunction tryParse(str, defValue) {\n    // TODO: test if value is valid and in range\n    if (str != null && /\\S/.test(str)) {\n        const v = +str.replace(\"_\", \"\");\n        if (!Number.isNaN(v)) {\n            defValue.contents = v;\n            return true;\n        }\n    }\n    return false;\n}\nfunction parse(str) {\n    const defValue = new _Types_js__WEBPACK_IMPORTED_MODULE_0__.FSharpRef(0);\n    if (tryParse(str, defValue)) {\n        return defValue.contents;\n    }\n    else {\n        throw new Error(`The input string ${str} was not in a correct format.`);\n    }\n}\n// JS Number.isFinite function evals false for NaN\nfunction isPositiveInfinity(x) {\n    return x === Number.POSITIVE_INFINITY;\n}\nfunction isNegativeInfinity(x) {\n    return x === Number.NEGATIVE_INFINITY;\n}\nfunction isInfinity(x) {\n    return x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY;\n}\nfunction max(x, y) {\n    return x > y ? x : y;\n}\nfunction min(x, y) {\n    return x < y ? x : y;\n}\nfunction maxMagnitude(x, y) {\n    return Math.abs(x) > Math.abs(y) ? x : y;\n}\nfunction minMagnitude(x, y) {\n    return Math.abs(x) < Math.abs(y) ? x : y;\n}\nfunction clamp(x, min, max) {\n    return x < min ? min : x > max ? max : x;\n}\n\n\n//# sourceURL=webpack:///./src/fable_modules/fable-library.4.5.0/Double.js?");

/***/ }),

/***/ "./src/fable_modules/fable-library.4.5.0/Global.js":
/*!*********************************************************!*\
  !*** ./src/fable_modules/fable-library.4.5.0/Global.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SR_differentLengths\": () => (/* binding */ SR_differentLengths),\n/* harmony export */   \"SR_indexOutOfBounds\": () => (/* binding */ SR_indexOutOfBounds),\n/* harmony export */   \"SR_inputMustBeNonNegative\": () => (/* binding */ SR_inputMustBeNonNegative),\n/* harmony export */   \"SR_inputSequenceEmpty\": () => (/* binding */ SR_inputSequenceEmpty),\n/* harmony export */   \"SR_inputSequenceTooLong\": () => (/* binding */ SR_inputSequenceTooLong),\n/* harmony export */   \"SR_inputWasEmpty\": () => (/* binding */ SR_inputWasEmpty),\n/* harmony export */   \"SR_keyNotFoundAlt\": () => (/* binding */ SR_keyNotFoundAlt),\n/* harmony export */   \"SR_notEnoughElements\": () => (/* binding */ SR_notEnoughElements)\n/* harmony export */ });\nconst SR_indexOutOfBounds = \"The index was outside the range of elements in the collection.\";\nconst SR_inputWasEmpty = \"Collection was empty.\";\nconst SR_inputMustBeNonNegative = \"The input must be non-negative.\";\nconst SR_inputSequenceEmpty = \"The input sequence was empty.\";\nconst SR_inputSequenceTooLong = \"The input sequence contains more than one element.\";\nconst SR_keyNotFoundAlt = \"An index satisfying the predicate was not found in the collection.\";\nconst SR_differentLengths = \"The collections had different lengths.\";\nconst SR_notEnoughElements = \"The input sequence has an insufficient number of elements.\";\n\n\n//# sourceURL=webpack:///./src/fable_modules/fable-library.4.5.0/Global.js?");

/***/ }),

/***/ "./src/fable_modules/fable-library.4.5.0/Native.js":
/*!*********************************************************!*\
  !*** ./src/fable_modules/fable-library.4.5.0/Native.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Helpers_allocateArrayFromCons\": () => (/* binding */ Helpers_allocateArrayFromCons)\n/* harmony export */ });\nfunction Helpers_allocateArrayFromCons(cons, len) {\n    if ((typeof cons) === \"function\") {\n        return new cons(len);\n    }\n    else {\n        return new Array(len);\n    }\n}\n\n\n//# sourceURL=webpack:///./src/fable_modules/fable-library.4.5.0/Native.js?");

/***/ }),

/***/ "./src/fable_modules/fable-library.4.5.0/Option.js":
/*!*********************************************************!*\
  !*** ./src/fable_modules/fable-library.4.5.0/Option.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Some\": () => (/* binding */ Some),\n/* harmony export */   \"bind\": () => (/* binding */ bind),\n/* harmony export */   \"defaultArg\": () => (/* binding */ defaultArg),\n/* harmony export */   \"defaultArgWith\": () => (/* binding */ defaultArgWith),\n/* harmony export */   \"filter\": () => (/* binding */ filter),\n/* harmony export */   \"flatten\": () => (/* binding */ flatten),\n/* harmony export */   \"map\": () => (/* binding */ map),\n/* harmony export */   \"map2\": () => (/* binding */ map2),\n/* harmony export */   \"map3\": () => (/* binding */ map3),\n/* harmony export */   \"ofNullable\": () => (/* binding */ ofNullable),\n/* harmony export */   \"orElse\": () => (/* binding */ orElse),\n/* harmony export */   \"orElseWith\": () => (/* binding */ orElseWith),\n/* harmony export */   \"some\": () => (/* binding */ some),\n/* harmony export */   \"toArray\": () => (/* binding */ toArray),\n/* harmony export */   \"toNullable\": () => (/* binding */ toNullable),\n/* harmony export */   \"tryOp\": () => (/* binding */ tryOp),\n/* harmony export */   \"unwrap\": () => (/* binding */ unwrap),\n/* harmony export */   \"value\": () => (/* binding */ value)\n/* harmony export */ });\n/* harmony import */ var _Util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Util.js */ \"./src/fable_modules/fable-library.4.5.0/Util.js\");\n\n// Using a class here for better compatibility with TS files importing Some\nclass Some {\n    constructor(value) {\n        this.value = value;\n    }\n    toJSON() {\n        return this.value;\n    }\n    // Don't add \"Some\" for consistency with erased options\n    toString() {\n        return String(this.value);\n    }\n    GetHashCode() {\n        return (0,_Util_js__WEBPACK_IMPORTED_MODULE_0__.structuralHash)(this.value);\n    }\n    Equals(other) {\n        if (other == null) {\n            return false;\n        }\n        else {\n            return (0,_Util_js__WEBPACK_IMPORTED_MODULE_0__.equals)(this.value, other instanceof Some ? other.value : other);\n        }\n    }\n    CompareTo(other) {\n        if (other == null) {\n            return 1;\n        }\n        else {\n            return (0,_Util_js__WEBPACK_IMPORTED_MODULE_0__.compare)(this.value, other instanceof Some ? other.value : other);\n        }\n    }\n}\nfunction value(x) {\n    if (x == null) {\n        throw new Error(\"Option has no value\");\n    }\n    else {\n        return x instanceof Some ? x.value : x;\n    }\n}\nfunction unwrap(opt) {\n    return opt instanceof Some ? opt.value : opt;\n}\nfunction some(x) {\n    return x == null || x instanceof Some ? new Some(x) : x;\n}\nfunction ofNullable(x) {\n    // This will fail with unit probably, an alternative would be:\n    // return x === null ? undefined : (x === undefined ? new Some(x) : x);\n    return x == null ? undefined : x;\n}\nfunction toNullable(x) {\n    return x == null ? null : value(x);\n}\nfunction flatten(x) {\n    return x == null ? undefined : value(x);\n}\nfunction toArray(opt) {\n    return (opt == null) ? [] : [value(opt)];\n}\nfunction defaultArg(opt, defaultValue) {\n    return (opt != null) ? value(opt) : defaultValue;\n}\nfunction defaultArgWith(opt, defThunk) {\n    return (opt != null) ? value(opt) : defThunk();\n}\nfunction orElse(opt, ifNone) {\n    return opt == null ? ifNone : opt;\n}\nfunction orElseWith(opt, ifNoneThunk) {\n    return opt == null ? ifNoneThunk() : opt;\n}\nfunction filter(predicate, opt) {\n    return (opt != null) ? (predicate(value(opt)) ? opt : undefined) : opt;\n}\nfunction map(mapping, opt) {\n    return (opt != null) ? some(mapping(value(opt))) : undefined;\n}\nfunction map2(mapping, opt1, opt2) {\n    return (opt1 != null && opt2 != null) ? mapping(value(opt1), value(opt2)) : undefined;\n}\nfunction map3(mapping, opt1, opt2, opt3) {\n    return (opt1 != null && opt2 != null && opt3 != null) ? mapping(value(opt1), value(opt2), value(opt3)) : undefined;\n}\nfunction bind(binder, opt) {\n    return opt != null ? binder(value(opt)) : undefined;\n}\nfunction tryOp(op, arg) {\n    try {\n        return some(op(arg));\n    }\n    catch {\n        return undefined;\n    }\n}\n\n\n//# sourceURL=webpack:///./src/fable_modules/fable-library.4.5.0/Option.js?");

/***/ }),

/***/ "./src/fable_modules/fable-library.4.5.0/Types.js":
/*!********************************************************!*\
  !*** ./src/fable_modules/fable-library.4.5.0/Types.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Attribute\": () => (/* binding */ Attribute),\n/* harmony export */   \"Exception\": () => (/* binding */ Exception),\n/* harmony export */   \"FSharpException\": () => (/* binding */ FSharpException),\n/* harmony export */   \"FSharpRef\": () => (/* binding */ FSharpRef),\n/* harmony export */   \"MatchFailureException\": () => (/* binding */ MatchFailureException),\n/* harmony export */   \"Record\": () => (/* binding */ Record),\n/* harmony export */   \"Union\": () => (/* binding */ Union),\n/* harmony export */   \"ensureErrorOrException\": () => (/* binding */ ensureErrorOrException),\n/* harmony export */   \"isException\": () => (/* binding */ isException),\n/* harmony export */   \"isPromise\": () => (/* binding */ isPromise),\n/* harmony export */   \"seqToString\": () => (/* binding */ seqToString),\n/* harmony export */   \"toString\": () => (/* binding */ toString),\n/* harmony export */   \"unionToString\": () => (/* binding */ unionToString)\n/* harmony export */ });\n/* harmony import */ var _Util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Util.js */ \"./src/fable_modules/fable-library.4.5.0/Util.js\");\n\nfunction seqToString(self) {\n    let count = 0;\n    let str = \"[\";\n    for (const x of self) {\n        if (count === 0) {\n            str += toString(x);\n        }\n        else if (count === 100) {\n            str += \"; ...\";\n            break;\n        }\n        else {\n            str += \"; \" + toString(x);\n        }\n        count++;\n    }\n    return str + \"]\";\n}\nfunction toString(x, callStack = 0) {\n    if (x != null && typeof x === \"object\") {\n        if (typeof x.toString === \"function\") {\n            return x.toString();\n        }\n        else if (Symbol.iterator in x) {\n            return seqToString(x);\n        }\n        else { // TODO: Date?\n            const cons = Object.getPrototypeOf(x)?.constructor;\n            return cons === Object && callStack < 10\n                // Same format as recordToString\n                ? \"{ \" + Object.entries(x).map(([k, v]) => k + \" = \" + toString(v, callStack + 1)).join(\"\\n  \") + \" }\"\n                : cons?.name ?? \"\";\n        }\n    }\n    return String(x);\n}\nfunction unionToString(name, fields) {\n    if (fields.length === 0) {\n        return name;\n    }\n    else {\n        let fieldStr;\n        let withParens = true;\n        if (fields.length === 1) {\n            fieldStr = toString(fields[0]);\n            withParens = fieldStr.indexOf(\" \") >= 0;\n        }\n        else {\n            fieldStr = fields.map((x) => toString(x)).join(\", \");\n        }\n        return name + (withParens ? \" (\" : \" \") + fieldStr + (withParens ? \")\" : \"\");\n    }\n}\nclass Union {\n    get name() {\n        return this.cases()[this.tag];\n    }\n    toJSON() {\n        return this.fields.length === 0 ? this.name : [this.name].concat(this.fields);\n    }\n    toString() {\n        return unionToString(this.name, this.fields);\n    }\n    GetHashCode() {\n        const hashes = this.fields.map((x) => (0,_Util_js__WEBPACK_IMPORTED_MODULE_0__.structuralHash)(x));\n        hashes.splice(0, 0, (0,_Util_js__WEBPACK_IMPORTED_MODULE_0__.numberHash)(this.tag));\n        return (0,_Util_js__WEBPACK_IMPORTED_MODULE_0__.combineHashCodes)(hashes);\n    }\n    Equals(other) {\n        if (this === other) {\n            return true;\n        }\n        else if (!(0,_Util_js__WEBPACK_IMPORTED_MODULE_0__.sameConstructor)(this, other)) {\n            return false;\n        }\n        else if (this.tag === other.tag) {\n            return (0,_Util_js__WEBPACK_IMPORTED_MODULE_0__.equalArrays)(this.fields, other.fields);\n        }\n        else {\n            return false;\n        }\n    }\n    CompareTo(other) {\n        if (this === other) {\n            return 0;\n        }\n        else if (!(0,_Util_js__WEBPACK_IMPORTED_MODULE_0__.sameConstructor)(this, other)) {\n            return -1;\n        }\n        else if (this.tag === other.tag) {\n            return (0,_Util_js__WEBPACK_IMPORTED_MODULE_0__.compareArrays)(this.fields, other.fields);\n        }\n        else {\n            return this.tag < other.tag ? -1 : 1;\n        }\n    }\n}\nfunction recordToJSON(self) {\n    const o = {};\n    const keys = Object.keys(self);\n    for (let i = 0; i < keys.length; i++) {\n        o[keys[i]] = self[keys[i]];\n    }\n    return o;\n}\nfunction recordToString(self) {\n    return \"{ \" + Object.entries(self).map(([k, v]) => k + \" = \" + toString(v)).join(\"\\n  \") + \" }\";\n}\nfunction recordGetHashCode(self) {\n    const hashes = Object.values(self).map((v) => (0,_Util_js__WEBPACK_IMPORTED_MODULE_0__.structuralHash)(v));\n    return (0,_Util_js__WEBPACK_IMPORTED_MODULE_0__.combineHashCodes)(hashes);\n}\nfunction recordEquals(self, other) {\n    if (self === other) {\n        return true;\n    }\n    else if (!(0,_Util_js__WEBPACK_IMPORTED_MODULE_0__.sameConstructor)(self, other)) {\n        return false;\n    }\n    else {\n        const thisNames = Object.keys(self);\n        for (let i = 0; i < thisNames.length; i++) {\n            if (!(0,_Util_js__WEBPACK_IMPORTED_MODULE_0__.equals)(self[thisNames[i]], other[thisNames[i]])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nfunction recordCompareTo(self, other) {\n    if (self === other) {\n        return 0;\n    }\n    else if (!(0,_Util_js__WEBPACK_IMPORTED_MODULE_0__.sameConstructor)(self, other)) {\n        return -1;\n    }\n    else {\n        const thisNames = Object.keys(self);\n        for (let i = 0; i < thisNames.length; i++) {\n            const result = (0,_Util_js__WEBPACK_IMPORTED_MODULE_0__.compare)(self[thisNames[i]], other[thisNames[i]]);\n            if (result !== 0) {\n                return result;\n            }\n        }\n        return 0;\n    }\n}\nclass Record {\n    toJSON() { return recordToJSON(this); }\n    toString() { return recordToString(this); }\n    GetHashCode() { return recordGetHashCode(this); }\n    Equals(other) { return recordEquals(this, other); }\n    CompareTo(other) { return recordCompareTo(this, other); }\n}\nclass FSharpRef {\n    get contents() {\n        return this.getter();\n    }\n    set contents(v) {\n        this.setter(v);\n    }\n    constructor(contentsOrGetter, setter) {\n        if (typeof setter === \"function\") {\n            this.getter = contentsOrGetter;\n            this.setter = setter;\n        }\n        else {\n            this.getter = () => contentsOrGetter;\n            this.setter = (v) => { contentsOrGetter = v; };\n        }\n    }\n}\n// EXCEPTIONS\n// Exception is intentionally not derived from Error, for performance reasons (see #2160)\nclass Exception {\n    constructor(message) {\n        this.message = message;\n    }\n}\nfunction isException(x) {\n    return x instanceof Exception || x instanceof Error;\n}\nfunction isPromise(x) {\n    return x instanceof Promise;\n}\nfunction ensureErrorOrException(e) {\n    // Exceptionally admitting promises as errors for compatibility with React.suspense (see #3298)\n    return (isException(e) || isPromise(e)) ? e : new Error(String(e));\n}\nclass FSharpException extends Exception {\n    toJSON() { return recordToJSON(this); }\n    toString() { return recordToString(this); }\n    GetHashCode() { return recordGetHashCode(this); }\n    Equals(other) { return recordEquals(this, other); }\n    CompareTo(other) { return recordCompareTo(this, other); }\n}\nclass MatchFailureException extends FSharpException {\n    constructor(arg1, arg2, arg3) {\n        super();\n        this.arg1 = arg1;\n        this.arg2 = arg2 | 0;\n        this.arg3 = arg3 | 0;\n        this.message = \"The match cases were incomplete\";\n    }\n}\nclass Attribute {\n}\n\n\n//# sourceURL=webpack:///./src/fable_modules/fable-library.4.5.0/Types.js?");

/***/ }),

/***/ "./src/fable_modules/fable-library.4.5.0/Util.js":
/*!*******************************************************!*\
  !*** ./src/fable_modules/fable-library.4.5.0/Util.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Comparer\": () => (/* binding */ Comparer),\n/* harmony export */   \"Enumerable\": () => (/* binding */ Enumerable),\n/* harmony export */   \"Enumerator\": () => (/* binding */ Enumerator),\n/* harmony export */   \"Lazy\": () => (/* binding */ Lazy),\n/* harmony export */   \"ObjectRef\": () => (/* binding */ ObjectRef),\n/* harmony export */   \"arrayHash\": () => (/* binding */ arrayHash),\n/* harmony export */   \"assertEqual\": () => (/* binding */ assertEqual),\n/* harmony export */   \"assertNotEqual\": () => (/* binding */ assertNotEqual),\n/* harmony export */   \"bigintHash\": () => (/* binding */ bigintHash),\n/* harmony export */   \"clamp\": () => (/* binding */ clamp),\n/* harmony export */   \"clear\": () => (/* binding */ clear),\n/* harmony export */   \"combineHashCodes\": () => (/* binding */ combineHashCodes),\n/* harmony export */   \"compare\": () => (/* binding */ compare),\n/* harmony export */   \"compareArrays\": () => (/* binding */ compareArrays),\n/* harmony export */   \"compareArraysWith\": () => (/* binding */ compareArraysWith),\n/* harmony export */   \"compareDates\": () => (/* binding */ compareDates),\n/* harmony export */   \"comparePrimitives\": () => (/* binding */ comparePrimitives),\n/* harmony export */   \"comparerFromEqualityComparer\": () => (/* binding */ comparerFromEqualityComparer),\n/* harmony export */   \"copyToArray\": () => (/* binding */ copyToArray),\n/* harmony export */   \"count\": () => (/* binding */ count),\n/* harmony export */   \"createAtom\": () => (/* binding */ createAtom),\n/* harmony export */   \"createObj\": () => (/* binding */ createObj),\n/* harmony export */   \"curry10\": () => (/* binding */ curry10),\n/* harmony export */   \"curry11\": () => (/* binding */ curry11),\n/* harmony export */   \"curry12\": () => (/* binding */ curry12),\n/* harmony export */   \"curry13\": () => (/* binding */ curry13),\n/* harmony export */   \"curry14\": () => (/* binding */ curry14),\n/* harmony export */   \"curry15\": () => (/* binding */ curry15),\n/* harmony export */   \"curry16\": () => (/* binding */ curry16),\n/* harmony export */   \"curry17\": () => (/* binding */ curry17),\n/* harmony export */   \"curry18\": () => (/* binding */ curry18),\n/* harmony export */   \"curry19\": () => (/* binding */ curry19),\n/* harmony export */   \"curry2\": () => (/* binding */ curry2),\n/* harmony export */   \"curry20\": () => (/* binding */ curry20),\n/* harmony export */   \"curry3\": () => (/* binding */ curry3),\n/* harmony export */   \"curry4\": () => (/* binding */ curry4),\n/* harmony export */   \"curry5\": () => (/* binding */ curry5),\n/* harmony export */   \"curry6\": () => (/* binding */ curry6),\n/* harmony export */   \"curry7\": () => (/* binding */ curry7),\n/* harmony export */   \"curry8\": () => (/* binding */ curry8),\n/* harmony export */   \"curry9\": () => (/* binding */ curry9),\n/* harmony export */   \"dateHash\": () => (/* binding */ dateHash),\n/* harmony export */   \"dateOffset\": () => (/* binding */ dateOffset),\n/* harmony export */   \"defaultOf\": () => (/* binding */ defaultOf),\n/* harmony export */   \"disposeSafe\": () => (/* binding */ disposeSafe),\n/* harmony export */   \"enumerableToIterator\": () => (/* binding */ enumerableToIterator),\n/* harmony export */   \"equalArrays\": () => (/* binding */ equalArrays),\n/* harmony export */   \"equalArraysWith\": () => (/* binding */ equalArraysWith),\n/* harmony export */   \"equals\": () => (/* binding */ equals),\n/* harmony export */   \"escapeDataString\": () => (/* binding */ escapeDataString),\n/* harmony export */   \"escapeUriString\": () => (/* binding */ escapeUriString),\n/* harmony export */   \"fastStructuralHash\": () => (/* binding */ fastStructuralHash),\n/* harmony export */   \"getEnumerator\": () => (/* binding */ getEnumerator),\n/* harmony export */   \"identityHash\": () => (/* binding */ identityHash),\n/* harmony export */   \"int16ToString\": () => (/* binding */ int16ToString),\n/* harmony export */   \"int32ToString\": () => (/* binding */ int32ToString),\n/* harmony export */   \"int64ToString\": () => (/* binding */ int64ToString),\n/* harmony export */   \"isArrayLike\": () => (/* binding */ isArrayLike),\n/* harmony export */   \"isComparable\": () => (/* binding */ isComparable),\n/* harmony export */   \"isComparer\": () => (/* binding */ isComparer),\n/* harmony export */   \"isDisposable\": () => (/* binding */ isDisposable),\n/* harmony export */   \"isEnumerable\": () => (/* binding */ isEnumerable),\n/* harmony export */   \"isEquatable\": () => (/* binding */ isEquatable),\n/* harmony export */   \"isHashable\": () => (/* binding */ isHashable),\n/* harmony export */   \"isIterable\": () => (/* binding */ isIterable),\n/* harmony export */   \"jsOptions\": () => (/* binding */ jsOptions),\n/* harmony export */   \"lazyFromValue\": () => (/* binding */ lazyFromValue),\n/* harmony export */   \"max\": () => (/* binding */ max),\n/* harmony export */   \"min\": () => (/* binding */ min),\n/* harmony export */   \"numberHash\": () => (/* binding */ numberHash),\n/* harmony export */   \"padLeftAndRightWithZeros\": () => (/* binding */ padLeftAndRightWithZeros),\n/* harmony export */   \"padWithZeros\": () => (/* binding */ padWithZeros),\n/* harmony export */   \"physicalEquality\": () => (/* binding */ physicalEquality),\n/* harmony export */   \"physicalHash\": () => (/* binding */ physicalHash),\n/* harmony export */   \"round\": () => (/* binding */ round),\n/* harmony export */   \"safeHash\": () => (/* binding */ safeHash),\n/* harmony export */   \"sameConstructor\": () => (/* binding */ sameConstructor),\n/* harmony export */   \"sign\": () => (/* binding */ sign),\n/* harmony export */   \"stringHash\": () => (/* binding */ stringHash),\n/* harmony export */   \"structuralHash\": () => (/* binding */ structuralHash),\n/* harmony export */   \"toEnumerable\": () => (/* binding */ toEnumerable),\n/* harmony export */   \"toIterator\": () => (/* binding */ toIterator),\n/* harmony export */   \"uncurry10\": () => (/* binding */ uncurry10),\n/* harmony export */   \"uncurry11\": () => (/* binding */ uncurry11),\n/* harmony export */   \"uncurry12\": () => (/* binding */ uncurry12),\n/* harmony export */   \"uncurry13\": () => (/* binding */ uncurry13),\n/* harmony export */   \"uncurry14\": () => (/* binding */ uncurry14),\n/* harmony export */   \"uncurry15\": () => (/* binding */ uncurry15),\n/* harmony export */   \"uncurry16\": () => (/* binding */ uncurry16),\n/* harmony export */   \"uncurry17\": () => (/* binding */ uncurry17),\n/* harmony export */   \"uncurry18\": () => (/* binding */ uncurry18),\n/* harmony export */   \"uncurry19\": () => (/* binding */ uncurry19),\n/* harmony export */   \"uncurry2\": () => (/* binding */ uncurry2),\n/* harmony export */   \"uncurry20\": () => (/* binding */ uncurry20),\n/* harmony export */   \"uncurry3\": () => (/* binding */ uncurry3),\n/* harmony export */   \"uncurry4\": () => (/* binding */ uncurry4),\n/* harmony export */   \"uncurry5\": () => (/* binding */ uncurry5),\n/* harmony export */   \"uncurry6\": () => (/* binding */ uncurry6),\n/* harmony export */   \"uncurry7\": () => (/* binding */ uncurry7),\n/* harmony export */   \"uncurry8\": () => (/* binding */ uncurry8),\n/* harmony export */   \"uncurry9\": () => (/* binding */ uncurry9),\n/* harmony export */   \"unescapeDataString\": () => (/* binding */ unescapeDataString)\n/* harmony export */ });\n// tslint:disable:ban-types\nfunction isArrayLike(x) {\n    return Array.isArray(x) || ArrayBuffer.isView(x);\n}\nfunction isIterable(x) {\n    return x != null && typeof x === \"object\" && Symbol.iterator in x;\n}\nfunction isEnumerable(x) {\n    return x != null && typeof x.GetEnumerator === \"function\";\n}\nfunction isComparer(x) {\n    return x != null && typeof x.Compare === \"function\";\n}\nfunction isComparable(x) {\n    return x != null && typeof x.CompareTo === \"function\";\n}\nfunction isEquatable(x) {\n    return x != null && typeof x.Equals === \"function\";\n}\nfunction isHashable(x) {\n    return x != null && typeof x.GetHashCode === \"function\";\n}\nfunction isDisposable(x) {\n    return x != null && typeof x.Dispose === \"function\";\n}\nfunction disposeSafe(x) {\n    if (isDisposable(x)) {\n        x.Dispose();\n    }\n}\nfunction defaultOf() {\n    return null;\n}\nfunction sameConstructor(x, y) {\n    return Object.getPrototypeOf(x)?.constructor === Object.getPrototypeOf(y)?.constructor;\n}\nclass Enumerable {\n    constructor(en) {\n        this.en = en;\n    }\n    GetEnumerator() { return this.en; }\n    \"System.Collections.IEnumerable.GetEnumerator\"() { return this.en; }\n    [Symbol.iterator]() {\n        return this;\n    }\n    next() {\n        const hasNext = this.en[\"System.Collections.IEnumerator.MoveNext\"]();\n        const current = hasNext ? this.en[\"System.Collections.Generic.IEnumerator`1.get_Current\"]() : undefined;\n        return { done: !hasNext, value: current };\n    }\n}\nclass Enumerator {\n    constructor(iter) {\n        this.iter = iter;\n        this.current = defaultOf();\n    }\n    [\"System.Collections.Generic.IEnumerator`1.get_Current\"]() {\n        return this.current;\n    }\n    [\"System.Collections.IEnumerator.get_Current\"]() {\n        return this.current;\n    }\n    [\"System.Collections.IEnumerator.MoveNext\"]() {\n        const cur = this.iter.next();\n        this.current = cur.value;\n        return !cur.done;\n    }\n    [\"System.Collections.IEnumerator.Reset\"]() {\n        throw new Error(\"JS iterators cannot be reset\");\n    }\n    Dispose() {\n        return;\n    }\n}\nfunction toEnumerable(e) {\n    if (isEnumerable(e)) {\n        return e;\n    }\n    else {\n        return new Enumerable(new Enumerator(e[Symbol.iterator]()));\n    }\n}\nfunction getEnumerator(e) {\n    if (isEnumerable(e)) {\n        return e.GetEnumerator();\n    }\n    else {\n        return new Enumerator(e[Symbol.iterator]());\n    }\n}\nfunction toIterator(en) {\n    return {\n        next() {\n            const hasNext = en[\"System.Collections.IEnumerator.MoveNext\"]();\n            const current = hasNext ? en[\"System.Collections.Generic.IEnumerator`1.get_Current\"]() : undefined;\n            return { done: !hasNext, value: current };\n        },\n    };\n}\nfunction enumerableToIterator(e) {\n    return toIterator(toEnumerable(e).GetEnumerator());\n}\nclass Comparer {\n    constructor(f) {\n        this.Compare = f || compare;\n    }\n}\nfunction comparerFromEqualityComparer(comparer) {\n    // Sometimes IEqualityComparer also implements IComparer\n    if (isComparer(comparer)) {\n        return new Comparer(comparer.Compare);\n    }\n    else {\n        return new Comparer((x, y) => {\n            const xhash = comparer.GetHashCode(x);\n            const yhash = comparer.GetHashCode(y);\n            if (xhash === yhash) {\n                return comparer.Equals(x, y) ? 0 : -1;\n            }\n            else {\n                return xhash < yhash ? -1 : 1;\n            }\n        });\n    }\n}\nfunction assertEqual(actual, expected, msg) {\n    if (!equals(actual, expected)) {\n        throw Object.assign(new Error(msg || `Expected: ${expected} - Actual: ${actual}`), {\n            actual,\n            expected,\n        });\n    }\n}\nfunction assertNotEqual(actual, expected, msg) {\n    if (equals(actual, expected)) {\n        throw Object.assign(new Error(msg || `Expected: ${expected} - Actual: ${actual}`), {\n            actual,\n            expected,\n        });\n    }\n}\nclass Lazy {\n    constructor(factory) {\n        this.factory = factory;\n        this.isValueCreated = false;\n    }\n    get Value() {\n        if (!this.isValueCreated) {\n            this.createdValue = this.factory();\n            this.isValueCreated = true;\n        }\n        return this.createdValue;\n    }\n    get IsValueCreated() {\n        return this.isValueCreated;\n    }\n}\nfunction lazyFromValue(v) {\n    return new Lazy(() => v);\n}\nfunction padWithZeros(i, length) {\n    let str = i.toString(10);\n    while (str.length < length) {\n        str = \"0\" + str;\n    }\n    return str;\n}\nfunction padLeftAndRightWithZeros(i, lengthLeft, lengthRight) {\n    let str = i.toString(10);\n    while (str.length < lengthLeft) {\n        str = \"0\" + str;\n    }\n    while (str.length < lengthRight) {\n        str = str + \"0\";\n    }\n    return str;\n}\nfunction dateOffset(date) {\n    const date1 = date;\n    return typeof date1.offset === \"number\"\n        ? date1.offset\n        : (date.kind === 1 /* DateKind.UTC */\n            ? 0 : date.getTimezoneOffset() * -60000);\n}\nfunction int16ToString(i, radix) {\n    i = i < 0 && radix != null && radix !== 10 ? 0xFFFF + i + 1 : i;\n    return i.toString(radix);\n}\nfunction int32ToString(i, radix) {\n    i = i < 0 && radix != null && radix !== 10 ? 0xFFFFFFFF + i + 1 : i;\n    return i.toString(radix);\n}\nfunction int64ToString(i, radix) {\n    i = i < 0 && radix != null && radix !== 10 ? 0xffffffffffffffffn + i + 1n : i;\n    return i.toString(radix);\n}\nclass ObjectRef {\n    static id(o) {\n        if (!ObjectRef.idMap.has(o)) {\n            ObjectRef.idMap.set(o, ++ObjectRef.count);\n        }\n        return ObjectRef.idMap.get(o);\n    }\n}\nObjectRef.idMap = new WeakMap();\nObjectRef.count = 0;\nfunction stringHash(s) {\n    let i = 0;\n    let h = 5381;\n    const len = s.length;\n    while (i < len) {\n        h = (h * 33) ^ s.charCodeAt(i++);\n    }\n    return h;\n}\nfunction numberHash(x) {\n    return x * 2654435761 | 0;\n}\nfunction bigintHash(x) {\n    return stringHash(x.toString(32));\n}\n// From https://stackoverflow.com/a/37449594\nfunction combineHashCodes(hashes) {\n    let h1 = 0;\n    const len = hashes.length;\n    for (let i = 0; i < len; i++) {\n        const h2 = hashes[i];\n        h1 = ((h1 << 5) + h1) ^ h2;\n    }\n    return h1;\n}\nfunction physicalHash(x) {\n    if (x == null) {\n        return 0;\n    }\n    switch (typeof x) {\n        case \"boolean\":\n            return x ? 1 : 0;\n        case \"number\":\n            return numberHash(x);\n        case \"bigint\":\n            return bigintHash(x);\n        case \"string\":\n            return stringHash(x);\n        default:\n            return numberHash(ObjectRef.id(x));\n    }\n}\nfunction identityHash(x) {\n    if (isHashable(x)) {\n        return x.GetHashCode();\n    }\n    else {\n        return physicalHash(x);\n    }\n}\nfunction dateHash(x) {\n    return x.getTime();\n}\nfunction arrayHash(x) {\n    const len = x.length;\n    const hashes = new Array(len);\n    for (let i = 0; i < len; i++) {\n        hashes[i] = structuralHash(x[i]);\n    }\n    return combineHashCodes(hashes);\n}\nfunction structuralHash(x) {\n    if (x == null) {\n        return 0;\n    }\n    switch (typeof x) {\n        case \"boolean\":\n            return x ? 1 : 0;\n        case \"number\":\n            return numberHash(x);\n        case \"bigint\":\n            return bigintHash(x);\n        case \"string\":\n            return stringHash(x);\n        default: {\n            if (isHashable(x)) {\n                return x.GetHashCode();\n            }\n            else if (isArrayLike(x)) {\n                return arrayHash(x);\n            }\n            else if (x instanceof Date) {\n                return dateHash(x);\n            }\n            else if (Object.getPrototypeOf(x)?.constructor === Object) {\n                // TODO: check call-stack to prevent cyclic objects?\n                const hashes = Object.values(x).map((v) => structuralHash(v));\n                return combineHashCodes(hashes);\n            }\n            else {\n                // Classes don't implement GetHashCode by default, but must use identity hashing\n                return numberHash(ObjectRef.id(x));\n                // return stringHash(String(x));\n            }\n        }\n    }\n}\n// Intended for custom numeric types, like long or decimal\nfunction fastStructuralHash(x) {\n    return stringHash(String(x));\n}\n// Intended for declared types that may or may not implement GetHashCode\nfunction safeHash(x) {\n    // return x == null ? 0 : isHashable(x) ? x.GetHashCode() : numberHash(ObjectRef.id(x));\n    return identityHash(x);\n}\nfunction equalArraysWith(x, y, eq) {\n    if (x == null) {\n        return y == null;\n    }\n    if (y == null) {\n        return false;\n    }\n    if (x.length !== y.length) {\n        return false;\n    }\n    for (let i = 0; i < x.length; i++) {\n        if (!eq(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction equalArrays(x, y) {\n    return equalArraysWith(x, y, equals);\n}\nfunction equalObjects(x, y) {\n    const xKeys = Object.keys(x);\n    const yKeys = Object.keys(y);\n    if (xKeys.length !== yKeys.length) {\n        return false;\n    }\n    xKeys.sort();\n    yKeys.sort();\n    for (let i = 0; i < xKeys.length; i++) {\n        if (xKeys[i] !== yKeys[i] || !equals(x[xKeys[i]], y[yKeys[i]])) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction physicalEquality(x, y) {\n    return x === y;\n}\nfunction equals(x, y) {\n    if (x === y) {\n        return true;\n    }\n    else if (x == null) {\n        return y == null;\n    }\n    else if (y == null) {\n        return false;\n    }\n    else if (isEquatable(x)) {\n        return x.Equals(y);\n    }\n    else if (isArrayLike(x)) {\n        return isArrayLike(y) && equalArrays(x, y);\n    }\n    else if (typeof x !== \"object\") {\n        return false;\n    }\n    else if (x instanceof Date) {\n        return (y instanceof Date) && compareDates(x, y) === 0;\n    }\n    else {\n        return Object.getPrototypeOf(x)?.constructor === Object && equalObjects(x, y);\n    }\n}\nfunction compareDates(x, y) {\n    let xtime;\n    let ytime;\n    // DateTimeOffset and DateTime deals with equality differently.\n    if (\"offset\" in x && \"offset\" in y) {\n        xtime = x.getTime();\n        ytime = y.getTime();\n    }\n    else {\n        xtime = x.getTime() + dateOffset(x);\n        ytime = y.getTime() + dateOffset(y);\n    }\n    return xtime === ytime ? 0 : (xtime < ytime ? -1 : 1);\n}\nfunction comparePrimitives(x, y) {\n    return x === y ? 0 : (x < y ? -1 : 1);\n}\nfunction compareArraysWith(x, y, comp) {\n    if (x == null) {\n        return y == null ? 0 : 1;\n    }\n    if (y == null) {\n        return -1;\n    }\n    if (x.length !== y.length) {\n        return x.length < y.length ? -1 : 1;\n    }\n    for (let i = 0, j = 0; i < x.length; i++) {\n        j = comp(x[i], y[i]);\n        if (j !== 0) {\n            return j;\n        }\n    }\n    return 0;\n}\nfunction compareArrays(x, y) {\n    return compareArraysWith(x, y, compare);\n}\nfunction compareObjects(x, y) {\n    const xKeys = Object.keys(x);\n    const yKeys = Object.keys(y);\n    if (xKeys.length !== yKeys.length) {\n        return xKeys.length < yKeys.length ? -1 : 1;\n    }\n    xKeys.sort();\n    yKeys.sort();\n    for (let i = 0, j = 0; i < xKeys.length; i++) {\n        const key = xKeys[i];\n        if (key !== yKeys[i]) {\n            return key < yKeys[i] ? -1 : 1;\n        }\n        else {\n            j = compare(x[key], y[key]);\n            if (j !== 0) {\n                return j;\n            }\n        }\n    }\n    return 0;\n}\nfunction compare(x, y) {\n    if (x === y) {\n        return 0;\n    }\n    else if (x == null) {\n        return y == null ? 0 : -1;\n    }\n    else if (y == null) {\n        return 1;\n    }\n    else if (isComparable(x)) {\n        return x.CompareTo(y);\n    }\n    else if (isArrayLike(x)) {\n        return isArrayLike(y) ? compareArrays(x, y) : -1;\n    }\n    else if (typeof x !== \"object\") {\n        return x < y ? -1 : 1;\n    }\n    else if (x instanceof Date) {\n        return y instanceof Date ? compareDates(x, y) : -1;\n    }\n    else {\n        return Object.getPrototypeOf(x)?.constructor === Object ? compareObjects(x, y) : -1;\n    }\n}\nfunction min(comparer, x, y) {\n    return comparer(x, y) < 0 ? x : y;\n}\nfunction max(comparer, x, y) {\n    return comparer(x, y) > 0 ? x : y;\n}\nfunction clamp(comparer, value, min, max) {\n    return (comparer(value, min) < 0) ? min : (comparer(value, max) > 0) ? max : value;\n}\nfunction createAtom(value) {\n    let atom = value;\n    return (...args) => {\n        if (args.length === 0) {\n            return atom;\n        }\n        else {\n            atom = args[0];\n        }\n    };\n}\nfunction createObj(fields) {\n    const obj = {};\n    for (const kv of fields) {\n        obj[kv[0]] = kv[1];\n    }\n    return obj;\n}\nfunction jsOptions(mutator) {\n    const opts = {};\n    mutator(opts);\n    return opts;\n}\nfunction round(value, digits = 0) {\n    const m = Math.pow(10, digits);\n    const n = +(digits ? value * m : value).toFixed(8);\n    const i = Math.floor(n);\n    const f = n - i;\n    const e = 1e-8;\n    const r = (f > 0.5 - e && f < 0.5 + e) ? ((i % 2 === 0) ? i : i + 1) : Math.round(n);\n    return digits ? r / m : r;\n}\nfunction sign(x) {\n    return x > 0 ? 1 : x < 0 ? -1 : 0;\n}\nfunction unescapeDataString(s) {\n    // https://stackoverflow.com/a/4458580/524236\n    return decodeURIComponent((s).replace(/\\+/g, \"%20\"));\n}\nfunction escapeDataString(s) {\n    return encodeURIComponent(s).replace(/!/g, \"%21\")\n        .replace(/'/g, \"%27\")\n        .replace(/\\(/g, \"%28\")\n        .replace(/\\)/g, \"%29\")\n        .replace(/\\*/g, \"%2A\");\n}\nfunction escapeUriString(s) {\n    return encodeURI(s);\n}\n// ICollection.Clear and Count members can be called on Arrays\n// or Dictionaries so we need a runtime check (see #1120)\nfunction count(col) {\n    if (isArrayLike(col)) {\n        return col.length;\n    }\n    else {\n        let count = 0;\n        for (const _ of col) {\n            count++;\n        }\n        return count;\n    }\n}\nfunction clear(col) {\n    if (isArrayLike(col)) {\n        col.splice(0);\n    }\n    else {\n        col.clear();\n    }\n}\nconst curried = new WeakMap();\nfunction uncurry2(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2) => f(a1)(a2);\n    curried.set(f2, f);\n    return f2;\n}\nfunction curry2(f) {\n    return curried.get(f) ?? ((a1) => (a2) => f(a1, a2));\n}\nfunction uncurry3(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3) => f(a1)(a2)(a3);\n    curried.set(f2, f);\n    return f2;\n}\nfunction curry3(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => f(a1, a2, a3));\n}\nfunction uncurry4(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4) => f(a1)(a2)(a3)(a4);\n    curried.set(f2, f);\n    return f2;\n}\nfunction curry4(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => f(a1, a2, a3, a4));\n}\nfunction uncurry5(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4, a5) => f(a1)(a2)(a3)(a4)(a5);\n    curried.set(f2, f);\n    return f2;\n}\nfunction curry5(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => (a5) => f(a1, a2, a3, a4, a5));\n}\nfunction uncurry6(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4, a5, a6) => f(a1)(a2)(a3)(a4)(a5)(a6);\n    curried.set(f2, f);\n    return f2;\n}\nfunction curry6(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => (a5) => (a6) => f(a1, a2, a3, a4, a5, a6));\n}\nfunction uncurry7(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4, a5, a6, a7) => f(a1)(a2)(a3)(a4)(a5)(a6)(a7);\n    curried.set(f2, f);\n    return f2;\n}\nfunction curry7(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => f(a1, a2, a3, a4, a5, a6, a7));\n}\nfunction uncurry8(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4, a5, a6, a7, a8) => f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8);\n    curried.set(f2, f);\n    return f2;\n}\nfunction curry8(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => (a8) => f(a1, a2, a3, a4, a5, a6, a7, a8));\n}\nfunction uncurry9(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4, a5, a6, a7, a8, a9) => f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8)(a9);\n    curried.set(f2, f);\n    return f2;\n}\nfunction curry9(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => (a8) => (a9) => f(a1, a2, a3, a4, a5, a6, a7, a8, a9));\n}\nfunction uncurry10(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) => f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8)(a9)(a10);\n    curried.set(f2, f);\n    return f2;\n}\nfunction curry10(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => (a8) => (a9) => (a10) => f(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10));\n}\nfunction uncurry11(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) => f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8)(a9)(a10)(a11);\n    curried.set(f2, f);\n    return f2;\n}\nfunction curry11(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => (a8) => (a9) => (a10) => (a11) => f(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11));\n}\nfunction uncurry12(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) => f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8)(a9)(a10)(a11)(a12);\n    curried.set(f2, f);\n    return f2;\n}\nfunction curry12(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => (a8) => (a9) => (a10) => (a11) => (a12) => f(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12));\n}\nfunction uncurry13(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13) => f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8)(a9)(a10)(a11)(a12)(a13);\n    curried.set(f2, f);\n    return f2;\n}\nfunction curry13(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => (a8) => (a9) => (a10) => (a11) => (a12) => (a13) => f(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13));\n}\nfunction uncurry14(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14) => f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8)(a9)(a10)(a11)(a12)(a13)(a14);\n    curried.set(f2, f);\n    return f2;\n}\nfunction curry14(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => (a8) => (a9) => (a10) => (a11) => (a12) => (a13) => (a14) => f(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14));\n}\nfunction uncurry15(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) => f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8)(a9)(a10)(a11)(a12)(a13)(a14)(a15);\n    curried.set(f2, f);\n    return f2;\n}\nfunction curry15(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => (a8) => (a9) => (a10) => (a11) => (a12) => (a13) => (a14) => (a15) => f(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15));\n}\nfunction uncurry16(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16) => f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8)(a9)(a10)(a11)(a12)(a13)(a14)(a15)(a16);\n    curried.set(f2, f);\n    return f2;\n}\nfunction curry16(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => (a8) => (a9) => (a10) => (a11) => (a12) => (a13) => (a14) => (a15) => (a16) => f(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16));\n}\nfunction uncurry17(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17) => f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8)(a9)(a10)(a11)(a12)(a13)(a14)(a15)(a16)(a17);\n    curried.set(f2, f);\n    return f2;\n}\nfunction curry17(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => (a8) => (a9) => (a10) => (a11) => (a12) => (a13) => (a14) => (a15) => (a16) => (a17) => f(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17));\n}\nfunction uncurry18(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18) => f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8)(a9)(a10)(a11)(a12)(a13)(a14)(a15)(a16)(a17)(a18);\n    curried.set(f2, f);\n    return f2;\n}\nfunction curry18(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => (a8) => (a9) => (a10) => (a11) => (a12) => (a13) => (a14) => (a15) => (a16) => (a17) => (a18) => f(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18));\n}\nfunction uncurry19(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19) => f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8)(a9)(a10)(a11)(a12)(a13)(a14)(a15)(a16)(a17)(a18)(a19);\n    curried.set(f2, f);\n    return f2;\n}\nfunction curry19(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => (a8) => (a9) => (a10) => (a11) => (a12) => (a13) => (a14) => (a15) => (a16) => (a17) => (a18) => (a19) => f(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19));\n}\nfunction uncurry20(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20) => f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8)(a9)(a10)(a11)(a12)(a13)(a14)(a15)(a16)(a17)(a18)(a19)(a20);\n    curried.set(f2, f);\n    return f2;\n}\nfunction curry20(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => (a8) => (a9) => (a10) => (a11) => (a12) => (a13) => (a14) => (a15) => (a16) => (a17) => (a18) => (a19) => (a20) => f(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20));\n}\n// More performant method to copy arrays, see #2352\nfunction copyToArray(source, sourceIndex, target, targetIndex, count) {\n    if (ArrayBuffer.isView(source) && ArrayBuffer.isView(target)) {\n        target.set(source.subarray(sourceIndex, sourceIndex + count), targetIndex);\n    }\n    else {\n        for (let i = 0; i < count; ++i) {\n            target[targetIndex + i] = source[sourceIndex + i];\n        }\n    }\n}\n\n\n//# sourceURL=webpack:///./src/fable_modules/fable-library.4.5.0/Util.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/App.fs.js");
/******/ 	
/******/ })()
;